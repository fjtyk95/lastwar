<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Swipe Attack Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
      background: #222;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 48px;
      display: none;
    }
    #pauseButton {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.3);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 24px;
      cursor: pointer;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #pauseMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      display: none;
      z-index: 200;
    }
    #pauseMenu button {
      background: #4CAF50;
      border: none;
      padding: 10px 20px;
      color: white;
      font-size: 20px;
      margin: 10px;
      border-radius: 5px;
      cursor: pointer;
    }
    #pauseMenu button:hover {
      background: #45a049;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <button id="pauseButton">⏸</button>
  <div id="pauseMenu">
    <h2 style="color: white; margin-bottom: 20px;">一時停止中</h2>
    <button id="resumeButton">再開</button>
  </div>
  <div id="gameOver">Game Over</div>
  <script>
    // キャンバス初期化
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ゲーム変数
    let enemies = [];
    let lastEnemySpawnTime = 0;
    const enemySpawnInterval = 2000; // 2秒ごとに出現
    let gameOver = false;
    let score = 0;
    let swipeEffects = [];
    let bullets = []; // 弾丸の配列を追加
    let player = {
      x: 0,
      y: 0,
      radius: 60, // さらに大きく（直径120px）
      isDragging: false
    };
    let isPaused = false;

    // 敵オブジェクト
    class Enemy {
      constructor(x, y, radius, hp, speedY) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.hp = hp;
        this.speedY = speedY; // px/ms
      }
      update(deltaTime) {
        this.y += this.speedY * deltaTime;
      }
      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.closePath();
        // HPを表示（必要に応じて）
        ctx.fillStyle = 'white';
        ctx.font = '24px sans-serif'; // フォントサイズを大きく
        ctx.fillText(Math.ceil(this.hp), this.x - 15, this.y + 8);
      }
    }

    // スワイプエフェクトクラスを追加
    class SwipeEffect {
      constructor(startX, startY, endX, endY) {
        this.startX = startX;
        this.startY = startY;
        this.endX = endX;
        this.endY = endY;
        this.alpha = 1.0;
        this.fadeSpeed = 0.05; // フェードアウトの速度
      }

      update() {
        this.alpha -= this.fadeSpeed;
        return this.alpha > 0;
      }

      draw(ctx) {
        ctx.beginPath();
        ctx.moveTo(this.startX, this.startY);
        ctx.lineTo(this.endX, this.endY);
        ctx.strokeStyle = `rgba(255, 255, 255, ${this.alpha})`;
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.closePath();
      }
    }

    // 弾丸クラスを修正
    class Bullet {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 20; // 弾のサイズも大きく
        this.speed = 0.5;
        this.damage = 8; // ダメージも増加
      }

      update(deltaTime) {
        this.y -= this.speed * deltaTime;
        return this.y > -this.radius;
      }

      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'yellow';
        ctx.fill();
        ctx.closePath();
      }

      checkCollision(enemy) {
        const dx = this.x - enemy.x;
        const dy = this.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < this.radius + enemy.radius;
      }
    }

    // 敵の出現を修正
    function spawnEnemy() {
      const radius = Math.random() * 50 + 50; // 50～100pxに変更
      const x = Math.random() * (canvas.width - 2 * radius) + radius;
      const y = -radius;
      const hp = 50; // HPも増加
      const speedY = Math.random() * 0.05 + 0.05;
      enemies.push(new Enemy(x, y, radius, hp, speedY));
    }

    // ポーズ関連の処理を追加
    const pauseButton = document.getElementById('pauseButton');
    const pauseMenu = document.getElementById('pauseMenu');
    const resumeButton = document.getElementById('resumeButton');

    pauseButton.addEventListener('click', function() {
      isPaused = true;
      pauseMenu.style.display = 'block';
    });

    resumeButton.addEventListener('click', function() {
      isPaused = false;
      pauseMenu.style.display = 'none';
      lastFrameTime = performance.now(); // フレーム時間をリセット
      requestAnimationFrame(gameLoop);
    });

    // ゲームループを修正
    let lastFrameTime = performance.now();
    function gameLoop(timestamp) {
      if (gameOver) {
        document.getElementById('gameOver').style.display = 'block';
        return;
      }
      
      if (!isPaused) {
        const deltaTime = timestamp - lastFrameTime;
        lastFrameTime = timestamp;
        
        update(deltaTime);
        draw();
        
        if (timestamp - lastEnemySpawnTime > enemySpawnInterval) {
          spawnEnemy();
          lastEnemySpawnTime = timestamp;
        }
        requestAnimationFrame(gameLoop);
      }
    }
    requestAnimationFrame(gameLoop);

    // プレイヤーの初期位置を設定
    function resetPlayerPosition() {
      player.x = canvas.width / 2;
      player.y = canvas.height - 120; // 画面下部の位置も調整
    }
    resetPlayerPosition();
    window.addEventListener('resize', resetPlayerPosition);

    // 更新処理
    function update(deltaTime) {
      // 敵の移動と当たり判定
      for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].update(deltaTime);
        if (enemies[i].y - enemies[i].radius > canvas.height) {
          gameOver = true;
          document.getElementById('gameOver').style.display = 'block';
        }
      }

      // 弾丸の更新と当たり判定
      bullets = bullets.filter(bullet => {
        const isActive = bullet.update(deltaTime);
        if (isActive) {
          enemies.forEach(enemy => {
            if (bullet.checkCollision(enemy)) {
              enemy.hp -= bullet.damage;
              return false;
            }
          });
        }
        return isActive;
      });

      // 新しい弾を発射（一定間隔で）
      if (!gameOver && !isPaused && performance.now() % 200 < 16) {
        bullets.push(new Bullet(player.x, player.y));
      }

      enemies = enemies.filter(enemy => enemy.hp > 0);
      swipeEffects = swipeEffects.filter(effect => effect.update());
    }

    // 描画処理
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // プレイヤーの描画
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fillStyle = 'blue';
      ctx.fill();
      ctx.closePath();

      bullets.forEach(bullet => bullet.draw(ctx));
      
      enemies.forEach(enemy => {
        enemy.draw(ctx);
        // HPの表示を大きく
        ctx.fillStyle = 'white';
        ctx.font = '24px sans-serif'; // フォントサイズを大きく
        ctx.fillText(Math.ceil(enemy.hp), enemy.x - 15, enemy.y + 8);
      });
      
      swipeEffects.forEach(effect => effect.draw(ctx));
      
      // スコア表示も大きく
      ctx.fillStyle = 'white';
      ctx.font = '32px sans-serif'; // スコアのフォントサイズを大きく
      ctx.fillText('Score: ' + score, 20, 50);
    }

    // タッチ操作のサポートを修正
    canvas.addEventListener('touchstart', function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const touchX = touch.clientX - rect.left;
      const touchY = touch.clientY - rect.top;
      
      // タッチ判定範囲を広げる
      const dx = touchX - player.x;
      const dy = touchY - player.y;
      if (dx * dx + dy * dy <= (player.radius * 1.5) * (player.radius * 1.5)) {
        player.isDragging = true;
      }
    });

    canvas.addEventListener('touchmove', function(e) {
      e.preventDefault();
      if (player.isDragging) {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const touchX = touch.clientX - rect.left;
        player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, touchX));
      }
    });

    canvas.addEventListener('touchend', function(e) {
      e.preventDefault();
      player.isDragging = false;
    });

    canvas.addEventListener('touchcancel', function(e) {
      e.preventDefault();
      player.isDragging = false;
    });
  </script>
</body>
</html>
